# -*- coding: utf-8 -*-
"""TP1_fin_les_classes

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/111CyK4cQVkCe4dRfsNbYgfNq9TdBfo6c
"""

# ____________On vérifie les capteur_____________

def distance_robot(x,y,z):
  liste = sorted((x,y,z));
  limite_bas = 0.5*liste[1];
  limite_haut = 1.5*liste[1];

#les trois capteurs foncionnent
  if liste[0]>= limite_bas and liste[2]<=limite_haut:
    return ((x+y+z)/3);

#le capteur à la valeur la plus basse est biaisé
  if liste[0]<= limite_bas and liste[2]<= limite_haut:
    return ((liste[1]+liste[2])/2);

#le capteur à la valeur la plus haute est biaisé
  if liste[0]>= limite_bas and liste[2]>= limite_haut:
    return ((liste[1]+liste[0])/2);

#Deux capteurs ou plus sont biaisés
  else :
    return(-1);


#print(distance_robot(5,5,5));

#______________On mesure les couts en deplacement et en temps du robot__________

def cout_deplacement(x1,y1,x2,y2,type):
  distance = ((x2 - x1)**2 + (y2-y1)**2)**0.5 ;

  if type == 'R' :
    return(distance);

  if type == 'H' :
    return(distance*1.5);

  if type == 'S' :
    return(distance*2);

  if type == 'O' :
    return(distance*3);

  else :
    return ('erreur');


def temps_trajet(x1,y1,x2,y2,type):
  distance = ((x2 - x1)**2 + (y2-y1)**2)**0.5 ;

  if type == 'R' :
    return(distance/2);

  if type == 'H' :
    return(distance/1.5);

  if type == 'S' :
    return(distance);

  if type == 'O' :
    return(distance/0.5);

  else :
    return ('erreur');


# print(cout_deplacement(0,0,3,4,'O'))
# print(temps_trajet(1,1,4,5,'R'))

#_________________________On crée la classe Position
class Position:

  def __init__(self,x = 0,y = 0): # si elle n'est pas def on fixe à 0
    # on déclare les attributs
    self.x = x
    self.y = y

# on utilise add pour informe que lorsque on additionne deux position on obtient
# ce ci-dessous ( une adition n'est pas forcement une vraie adition suivant ce
# que l'on définit dans la classe)

  def __add__(self, autre):
    return( Position(self.x + autre.x,self.y + autre.y));

  def afficher(self):
    print(f"Position(x={self.x},y={self.y})");

  def distance_vers(self,autre):
    return (((autre.x - self.x)**2 + (autre.y-self.y)**2)**0.5);


# pos1 = Position(0,0)
# pos1.afficher() # Position(x=0, y=0)
# pos2 = Position(3, 4)
# pos2.afficher() # Position(x=3, y=4)
# pos3 = pos1 + pos2
# pos3.afficher() # Position(x=3, y=4)

# print(pos1.distance_vers(pos2));

#______________________________On definit la classe Robot_______________________
class Robot() :

  def __init__(self,x=0,y=0):
    self.x=x
    self.y=y

  def avancer_droite(self,x):
    self.x = self.x + x;

  def avancer_haut(self,y):
    self.y = self.y + y;

  def afficher(self):
    print(f"Robot à position Position(x={self.x}, y={self.y})");



# robot = Robot()
# robot.afficher()
# robot.avancer_droite(3)
# robot.avancer_haut(4)
# robot.afficher()

# On redéfinit la classe Robot ce qui va supprimer dans la compilation celle
#précédente

class Robot() :

  def __init__(self,pos = Position(0,0)): #On utilise la classe précédente
    self.pos = pos

  def avancer_droite(self,x):
    self.pos.x = self.pos.x + x #on accede aux valeur définit dans la classe précédente

  def avancer_haut(self,y):
    self.pos.y = self.pos.y + y

  def afficher(self):
    print(f"Robot à position Position(x={self.pos.x}, y={self.pos.y})")

  def distance_vers_robot(self,autre_robot : Robot):
    return self.pos.distance_vers(autre_robot.pos)
    # on utilise une fonction de la classe Parcours

  def aller_vers(self,autre_pos : Position):
    self.pos = autre_pos
    # faire attention de bien mettre deux positions



# robot1 = Robot(Position(0, 0))
# robot2 = Robot(Position(3, 4))
# print(robot1.distance_vers_robot(robot2))
# robot1.afficher()
# robot1.aller_vers(Position(2, 3))
# robot1.afficher()

#______________________On définit la classe Cible______________________________
class Cible :
  def __init__(self,pos : Position,nom : str):
    self.pos = pos
    self.nom = nom

  def est_atteinte_par(self, robot : Robot):
    return self.pos.x == robot.pos.x and self.pos.y == robot.pos.y
    # on ne peut pas comparer des pointeurs , on doit comparer des valeurs

  def distance_depuis(self,robot : Robot):
    return self.pos.distance_vers(robot.pos)

  def afficher(self):
    print(f"Cible {self.nom} Position(x={self.pos.x}, y={self.pos.y})")


# cible = Cible(Position(5, 3), "Sortie")
# robot = Robot(Position(0, 3))
# print(cible.est_atteinte_par(robot))
# print(cible.distance_depuis(robot))
# cible.afficher()

#_____________________On définit la classe Parcours_____________________________
class Parcours:
  def __init__(self): # Parcour() ne prend pas d'arguments
    self.cible = []   # mais contient une liste vide

  def  ajouter_cible(self, cible : Cible ):
    self.cible.append(cible) # on utilise append() pour ajouter un element à la liste

  def nombre_cible(self):
    return len(self.cible) # on utilise len() pour avoir la taille de la liste

  def afficher(self):
    for i in range(self.nombre_cible()):  #on parcour la liste
      cible = self.cible[i]               #on sort de la liste la cible
      print(f"Cible {cible.nom} pos({cible.pos.x},{cible.pos.y})")

      #on ne peut pas directement rentrer dans la liste et accéder aux valeur
      # exemple : self.cible[i].nom

  def cible_suivante(self,cible : Cible):
    i = self.cible.index(cible)
    return self.cible[i + 1]

# on peut soit utiliser deux méthode pour créer executer parcours
# - on utilise nombre_cible(), on parcours la liste avec for
# - on utilise cible_suivante() et nombre_cible, on parcours la liste avec while
  def executer_parcours(self, robot : Robot):
    for i in range (self.nombre_cible()):
      cible = self.cible[i]
      position = cible.pos
      #robot.afficher()
      robot.aller_vers(position)
      #robot.afficher()


# parcours = Parcours()
# c1 = Cible(Position(2, 0), "Point A")
# c2 = Cible(Position(2, 3), "Point B")
# c3 = Cible(Position(5, 3), "Point C")


# parcours.ajouter_cible(c1)
# parcours.ajouter_cible(c2)
# parcours.ajouter_cible(c3)

# print(parcours.nombre_cible())

# print(parcours.cible_suivante(c2))

# parcours.afficher()
# robote = Robot()
# parcours.executer_parcours(robote)

# if c3.est_atteinte_par(robote) == True :
#   print( 'cible atteinte')
# else :
#   print('cible non atteinte')

#______________________On définit la classe Terrain_____________________________
class Terrain:
  def __init__(self):
    self.robot = []


  def ajouter_robot(self, robot : Robot ):
    self.robot.append(robot)

  def definir_parcours(self, parcours : Parcours):
    self.parcours = parcours

  def lancer_mission(self):
    n = len(self.robot)
    for i in range(n) :
      r = self.robot[i]
      self.parcours.executer_parcours(r)

  def afficher_etat(self):
    n = len(self.robot)
    for i in range(n) :
      r = self.robot[i]
      r.afficher()

# rien de nouveau

# terrain = Terrain()
# robot10 = Robot(Position(0, 0))
# robot20 = Robot(Position(1, 1))
# terrain.ajouter_robot(robot10)
# terrain.ajouter_robot(robot20)
# parcours = Parcours()
# parcours.ajouter_cible(Cible(Position(9, 9), "A"))
# parcours.ajouter_cible(Cible(Position(3, 1), "B"))
# parcours.ajouter_cible(Cible(Position(1, 3), "C"))
# parcours.ajouter_cible(Cible(Position(3, 3), "Objectif"))
# terrain.definir_parcours(parcours)
# terrain.lancer_mission()
# terrain.afficher_etat()

def demonstration_complete():
  terrain = Terrain()
  robot1 = Robot(Position(0, 0))
  robot2 = Robot(Position(1, 1))
  terrain.ajouter_robot(robot1)
  terrain.ajouter_robot(robot2)

  parcours = Parcours()
  parcours.ajouter_cible(Cible(Position(9, 9), "A"))
  parcours.ajouter_cible(Cible(Position(3, 1), "B"))
  parcours.ajouter_cible(Cible(Position(1, 3), "C"))

  terrain.definir_parcours(parcours)
  terrain.lancer_mission()
  terrain.afficher_etat()


demonstration_complete()

# je ne comprend pas l'idée de leur faire executer le même parcours.