# -*- coding: utf-8 -*-
"""Untitled1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ZDhDxdKI6HMVbkvxdxDmDBMf0Fxg--fc
"""

# On importe des biliotheques les fondtions pour les calsses abstraites et pour les aléatoires
from abc import ABC, abstractmethod
from random import randint
from random import shuffle

#__________________________Création classe abstraite Carte______________________

class Carte(ABC):
  #je n'initialise aucun attributs commun, pas besion ici

  @abstractmethod # obligatoire pour les classe abstraites
  def appliquer(self, joueur): # les fonctions vont forcement exister dans les heritiers
    pass  # pas de fonction communes aux heritiers

  @abstractmethod
  def type_carte(self):
    pass

  # un héritier ne peux avoir plus de fonctions

#_________________________Creation classe Carte normale,bonus...________________

class Carte_normale(Carte):# hérite de la classe abstraite Carte
    def appliquer(self, joueur):
        valeur = randint(1, 10)
        joueur.score += valeur
        return valeur  # on return la valeur de l'augmentation pour pouvoir l'utiliser

    def type_carte(self):
        return "normale"

class Carte_bonus(Carte):
    def appliquer(self, joueur):
        joueur.score *= 2
        return int(joueur.score/2)

    def type_carte(self):
        return "bonus"

class Carte_malus(Carte):
    def appliquer(self, joueur):
        valeur = -5
        joueur.score += valeur
        return valeur

    def type_carte(self):
        return "malus"


class Carte_chance(Carte):
    def appliquer(self, joueur):
        valeur = randint(-5, 15)
        joueur.score += valeur
        return valeur

    def type_carte(self):
        return "chance"

#________________________Creation class Joueur__________________________________

class Joueur:
    def __init__(self, nom: str, score=0):
        self.nom = nom
        self.score = score

    def jouerCarte(self, carte : Carte):
        effet = carte.appliquer(self) #appel la methode appliquer
        return effet # return la valeur de l'augmentation/diminution du score

    def afficher_score(self):
        print(f"Le score de {self.nom} est de {self.score}")


#______________________________Création fonction deck___________________________
def creer_deck():
  d=[]
  for i in range(30):
    d.append(Carte_normale)
  for i in range(6):
    d.append(Carte_bonus)
  for i in range(5):
    d.append(Carte_malus)
  for i in range(15):
    d.append(Carte_chance)
  return d

#______________________________Création de la fonction Partie___________________
def partie():

  deck = creer_deck()                           #on cree le deck
  shuffle(deck)                                 #on le mélange

  nom1 = input("Entrez le nom du joueur 1 : ")  #on demande le nom du premier joueur
  joueur1 = Joueur(nom1)
  nom2 = input("Entrez le nom du joueur 2 : ")  #du second
  joueur2 = Joueur(nom2)
  joueurs = [joueur1, joueur2]


  m = 0 #index du joueur qui joue
  s = 0 #le score max
  mmax = 0 #le joueur avec le score max

  # on effectue 10 tours
  for i in range(10):
      print()

      #on sort le type de cart du deck
      carte_class = deck[i]
      carte = carte_class()

      # on présente le joueur et sa carte pioché
      j = joueurs[m]
      print(f"Tour {i+1} : {j.nom} tire une carte {carte.type_carte()}")

      # on cherche l'effet de la carte et on modifie les points du joueur
      effet = j.jouerCarte(carte)

      #on présente l'effet de la carte
      if effet >= 0:
          print(f"Effet : Ajoute {effet} points.")
      else:
          print(f"Effet : Enlève {-effet} points.")

      #On affiche le score du joueur
      j.afficher_score()
      print()

      # garde en memoire le meilleur
      if j.score > s :
        mmax = m
      s = max(s, j.score)

      # Changement de joueur
      m = 1 - m


  # une fois la partie finie on donne le vainqueur
  j = joueurs[mmax]
  print (f'Score final et gagnant de {j.nom} : {j.score}')

partie()